# SKN08-1st-2Team

<div align="center">
  <img src="https://capsule-render.vercel.app/api?type=waving&color=0:000000,70:003300,100:00FF00&height=240&text=SKN08-1st-2Team&animation=&fontColor=00FF00&fontSize=90" width="1000" />
  
  <img width="1000" alt="image" src="https://github.com/Jh-jaehyuk/Jh-jaehyuk.github.io/assets/126551524/7ea63fc3-95f0-44d5-a0f0-cf431cae34f1"> 
  
  [![Hits](https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https://github.com/SKNETWORKS-FAMILY-AICAMP/SKN08-1st-2Team&count_bg=%2379C83D&title_bg=%23555555&icon=&icon_color=%23E7E7E7&title=hits&edge_flat=false)](https://hits.seeyoufarm.com)
</div>



# 0. Introduction Team (팀 소개)
### ✅ 팀명 : COTRIS
<table align=center>
  <tbody>
    <tr>
      <td align=center><b>박주희</b></td>
      <td align=center><b>최병준</b></td>
      <td align=center><b>조준희</b></td>
      <td align=center><b>오민수</b></td>
    </tr>
    <tr>
      <td align="center">
        <div>
          <img src="https://cdn.discordapp.com/attachments/1314480175118815272/1314484992184680459/371c2fe51ed1cd9d.png?ex=6753f10c&is=67529f8c&hm=ddaaffbbd84c96501c5845308911eebdbb122c5e7f5d981cc3e38b25c622ba39&"width="200px; alt=""/>
        </div>
      </td>
      <td align="center">
        <div>
          <img src="https://avatars.githubusercontent.com/u/188127748?v=4"width="200px; alt=""/>
        </div>
      </td>
      <td align="center">
        <img src="https://avatars.githubusercontent.com/u/188949785?v=4"width="200px; alt=""/>
      </td>
      <td align="center">
        <img src="https://cdn.discordapp.com/attachments/1314491560972259388/1314491631646412873/2024-12-06_4.19.04.png?ex=6753f73b&is=6752a5bb&hm=eb1a84cdbff28ee5a9e9f4095db117c4b41916ce54ee9844d94f97c78119b1b3&"width="200px; alt=""/>
      </td>
    </tr>
    <tr>
      <td><a href="https://github.com/Joey9797"><div align=center>@Joey9797</div></a></td>
      <td><a href="https://github.com/ChoiByuengJun"><div align=center>@ChoiByuengJun</div></a></td>
      <td><a href="https://github.com/CodeLego8"><div align=center>@CodeLego8</div></a></td>
      <td><a href="https://github.com/yooodleee"><div align=center>@yooodleee</div></a></td>
    </tr>
  </tbody>
</table>
<br><br><br>



# 1. Introduction Project (프로젝트 개요)

### ✅프로젝트 명
논문 요약 및 설명 제공 서비스

### ✅프로젝트 소개
논문 요약 및 설명 제공 서비스

### ✅프로젝트 필요성(배경)
- 새로운 기술에 대한 연구가 과거 대비 매우 빠른 속도로 발표되고 있습니다.
- 이에 새로운 기술을 논문을 통해 접하고자 하는 니즈가 발생하고 있음을 발견하였고, 이러한 니즈를 충족시키기 위해 논문을 읽을 수 있는 방식을 LLM을 통해 제공하여 많은 사람들이 이용할 수 있도록 서비스화하고자 합니다.

### ✅프로젝트 목표
1. Front-End에서는 **TypeScript**와 **Vue.js + Vuetify3**를 이용하여 사용자 측면에서 유리한 UI-UX를 구축하였고, **Axios** 를 통해서 올바른 Request를 하는 것을 목표로 삼았습니다. 
2. Back-End에서는 **Python**과 **Django**, **MySQL** 등을 이용하여 Request에 대한 정확한 Response와 원활한 웹사이트 운영하는 것을 목표로 삼았습니다.
3. Fast API에서는 **Machine Learning** **Deep Learning** 이용하여 데이터를 분석 및 예측할 수 있도록 하였습니다.
4. Deep Learning Local Server (DLLS) 에서는 **Fast API와 AI Client의 비동기 통신 환경**을 소켓 통신으로 구축하여 일반적인 동기 Request들이 처리될 때, 정상적으로 동작하도록 구축하였습니다.
5. CI-CD는 지속적인 코드 통합과 지속적인 배포를 통해 궁극적으로 개발 속도를 높이고, 코드 품질을 유지하며, 개발과 운영의 경계를 허물며 신속하게 가치를 제공하는 것을 목표로 삼았습니다. 
<br><br><br>



# 2. Tech Stack (기술 스택)

>### <span style="color:cyan"> Co-Work Tool </span>
<table>
  <tr>
    <td>Communication & Messenger</td>
    <td><img src="https://img.shields.io/badge/Discord-5865F2?style=flat&logo=Discord&logoColor=white"/></td>
    <td><img src="https://img.shields.io/badge/Notion-000000?style=flat&logo=Notion&logoColor=white"/></td>
    <td><img src="https://img.shields.io/badge/Slack-4A154B?style=flat&logo=Slack&logoColor=white"/></td>
  </tr>
  <tr>
    <td>Development & Merge</td>
    <td><img src="https://img.shields.io/badge/Git-F05032?style=flat&logo=Git&logoColor=white"/></td>
    <td><img src="https://img.shields.io/badge/GitHub-181717?style=flat&logo=GitHub&logoColor=white"/></td>
    
</table>

>### <span style="color:cyan"> Frontend </span>
<table>
  </tr>
  <tr>
    <td>Markup & Style & JS</td>
    <td><img src="https://img.shields.io/badge/HTML-E34F26?style=flat&logo=html5&logoColor=white"/></td>
    <td><img src="https://img.shields.io/badge/css-1572B6?style=flat&logo=css3&logoColor=white"/></td>
</table>

>### <span style="color:cyan"> Backend </span>
<table>
  <tr>
    <td>BE IDE & Language</td>
    <td><img src="https://img.shields.io/badge/pycharm-%23000000?style=flat&logo=pycharm&logoColor=white"/></td>
    <td><img src="https://img.shields.io/badge/python-3776AB?style=flat&logo=python&logoColor=white"/></td>
  </tr>  
  <tr>
    <td>RDBMS</td>
    <td><img src="https://img.shields.io/badge/mysql-4479A1?style=flat&logo=mysql&logoColor=white"/></td>
    <td></td>
  </tr>
  
</table>
<br><br><br>



# 3. 시스템 구성도
![image](https://github.com/user-attachments/assets/66a78240-b41d-487a-8800-29bccbab7d41)
<br><br><br>



## 애자일 보드를 사용하는 이유
```c
과거 정의서들을 일일히 작성하였지만 빠른 속도로 무언가를 개발하는데 한계가 있습니다.
처음부터 많은 것들을 빌드업하면서 빠른 생산성을 기반으로 움직이려면 반드시 애자일해야합니다.
고로 폭포수 설계 방식이 아닌 애자일 프로세스 방식으로 애자일 보드를 작성하면서 진행했습니다.

애자일 보드는 자체적으로 제목이 요구 사항을 내포하며 각 카드 내부에는 정의한 Domain의 세부 사항이 기록됩니다.
고로 빠르게 팀원들과 협업 할 수 있고 소통 비용을 최소화시킬 수 있습니다.
작은 것 같지만 이와 같은 것들이 쌓여서 아주 기민하고 민첩한 조직을 만들어 냅니다.
```
# 4. 애자일 보드
### ✅ Frontend - Frontend 페이지를 Vue 로 구성 (화면 설계서)
![image](https://github.com/user-attachments/assets/b547b885-25f8-413f-ab40-3251e8b77e95)
![image](https://github.com/user-attachments/assets/b947d9db-b2d1-4494-8842-82285289d6ff)
<br><br><br>

### ✅ Backend - Backend 데이터 관리로 Django 구성(요구 사항 정의서)
![image](https://github.com/user-attachments/assets/89ece460-81bd-44cf-bc7d-644487b3b267)
<br><br><br>

### ✅ FastAPI - AI 서빙용으로 FastAPI 구성
![image](https://github.com/user-attachments/assets/ccd6592b-4e7c-4fab-a7fe-6f16e8515195)
<br><br><br>

### ✅ AI Client - 비용 최적화를 위해 DLLS 구성 (모델 파인튜닝 및 추론 설계서)
![image](https://github.com/user-attachments/assets/ee098b0b-77b0-4e53-9a47-836e61081638)
<br><br><br>



# 5. 비용 최적화를 위한 Deep Learning Local Server 구성 + 보안 설정을 위한 TLS / SSL 소켓 구성
### 5-1 Socket Server (FastAPI) 구성 및 구동 방법
(1) FastAPI 프로젝트 폴더 내에서 미리 구성해 놓은 소켓 통신 관련 submodule을 다음의 명령어를 통해 연결합니다.
```bash
git submodule add "socket server submodule Github 주소" template
```

(2) 다음과 같이 `template` 라는 submodule이 프로젝트 내부에 붙은 것을 확인할 수 있습니다.
![image](https://github.com/user-attachments/assets/fc83fd3b-3cf0-4852-a6e1-c143afb3eed3)
(3) 이후에 `cd include/socket_server/`에 소켓 서버의 역할을 하도록 해놓은 모듈에 대한 내용들을 다음의 명령어로 갱신시킵니다.
![image](https://github.com/user-attachments/assets/1bf1190e-1aad-45d9-ad6b-d44090f88c0f)
```bash
cd ../..
git submodule update --init --recursive
```
(4) 그러면 아래처럼 내용들이 추가된 것을 확인할 수 있습니다.
![image](https://github.com/user-attachments/assets/bb624477-e11a-461c-a532-63389108c566)

(5) 이후 미리 준비해놓은 보안 관련 파일들을 프로젝트 폴더에 배치시킵니다.
```bash
CA.pem
svr.key
svr.crt
```

(6) 서버를 구동시키면 다음과 같이 ai-client의 접속을 대기하는 것을 확인할 수 있습니다.
![image](https://github.com/user-attachments/assets/dbdf40fe-1fc0-4e15-9c05-73618d202e63)

### 5-2 Socket Client (ai-client) 구성 및 구동 방법
(1) ai-client 프로젝트 폴더 내에서 소켓 서버와 마찬가지로 미리 구성해 놓은 소켓 통신 관련 submodule을 다음의 명령어를 통해 연결합니다.
```bash
git submodule add "socket client submodule Github 주소" template
```

(2) 다음과 같이 `template` 라는 submodule이 프로젝트 내부에 붙은 것을 확인할 수 있습니다.
![image](https://github.com/user-attachments/assets/7340470c-97c3-4ee4-ab18-d52bbc6a8c83)

(3) 이후 미리 준비해놓은 보안 관련 파일들을 프로젝트 폴더에 배치시킵니다.
```bash
CA.pem
client.key
client.crt
```

(4) 서버를 구동시킨 상태에서 ai-client를 구동하여 socket server로 접속을 시도하면 다음과 같이 잘 접속되는 것을 확인할 수 있습니다. 또한, 미리 구성한 보안 접속도 잘 작동하는 것을 확인할 수 있습니다.
![image](https://github.com/user-attachments/assets/98fdf151-ee23-41ba-a09d-fc1ac6ffd2d0)


# 6. 데이터 전처리

## 벡터 저장소
검색 속도 향상을 위해, FAISS를 사용하여 벡터 저장소를 생성 및 저장합니다. 
<br>FAISS를 사용하기 위해 텍스트를 청크 단위로 나눈 후 Document 형태로 변환합니다.

```python
def splitTextIntoDocuments(self, text, chunkSize=256, chunkOverlap=16):
    textSplitter = RecursiveCharacterTextSplitter(chunk_size=chunkSize, chunk_overlap=chunkOverlap)
    chunkList = textSplitter.split_text(text)

    documentList = [Document(page_content=chunk) for chunk in chunkList]
    return documentList
```
이후, 임베딩을 통해 벡터화를 진행한 뒤 FAISS를 사용하여 벡터 저장소를 생성하고 저장합니다.

```python
def createFAISS(self, documentList):
    embeddings = OpenAIEmbeddings()

    vectorstore = FAISS.from_documents(documentList, embeddings)
    print("success to create VectorStore")

    return vectorstore

def saveFAISS(self, vectorstore, dbPath):
    vectorstore.save_local(dbPath)
```

## TF-IDF 기반의 벡터 산출
사용자로부터 논문 요약을 요청받았을 때, 전체 텍스트를 모두 사용하는 것은 비효율적일 수 있기 때문에 텍스트의 길이를 줄이는 추가적인 작업이 필요합니다.
<br>먼저, 텍스트를 문장 단위로 나누고 TF-IDF 벡터를 생성합니다.
```python
sentences = sent_tokenize(mainText)

vectorizer = TfidfVectorizer().fit_transform(sentences)
vectors = vectorizer.toarray()
```
문장 간 유사도 행렬을 계산하고, 그 기반으로 그래프를 생성합니다.
```python
similarityMatrix = cosine_similarity(vectors)

nxGraph = nx.from_numpy_array(similarityMatrix)
scores = nx.pagerank(nxGraph)
```
점수에 따라 문장을 정렬한 뒤, 사용할 문장의 수를 잘 설정하여 선택합니다.
```python
rankedSentences = sorted(((scores[i], s) for i, s in enumerate(sentences)), reverse=True)
top_n = 100
rankedText = " ".join([sentence for score, sentence in rankedSentences[:top_n]])
```

# 7. 모델
LLama3.0, LLama3.1, OpenAI API 등 여러 모델을 사용해 보고, 입력 토큰 수와 추론 속도를 고려하여
<br>최종적으로 OpenAI의 gpt-4o-mini 모델을 선택하고, LangChain을 활용했습니다.

## Basic
LLM과 프롬프트 템플릿을 연결하여 체인을 만들고, 사용자가 보낸 메시지(userSendMessage)를 받아 question 변수에 해당하는 값으로 프롬프트 템플릿에 적용하고, 이를 통해 LLM이 텍스트를 생성하는 작업을 실행합니다.
```python
llm = ChatOpenAI(temperature=0.3, model_name="gpt-4o-mini")
prompt_template = PromptTemplate(
    input_variables=["question"],
    template=template
)

chain = LLMChain(llm=self.llm, prompt=prompt_template)
return {"generatedText": chain.run(userSendMessage)}
```

## 질의 응답
논문 관련 질의응답 시, LLM의 단점인'사실 관계 오류 가능성'과 '맥락 이해의 관계'를 개선하기 위해 RAG(Retrieval-Augmented Generation)를 사용했습니다.
<br>LangChain을 사용하여 RAG 체인을 구성하고, 사용자의 입력을 처리한 후 그에 대한 답변을 생성합니다.
<br>LangChain 허브에서 프롬프트를 불러온 뒤, RAG체인을 구성합니다. RAG는 외부 데이터를 검색하고, 이를 LLM을 통해 답변을 생성하는 방식으로 동작합니다.
<br>vectorstore.as_retriever()를 통해 전처리 과정에서 생성된 FAISS 벡터 저장소에서 문서를 검색하고, 사용자의 입력과 유사한 문서를 결과로 반환합니다.
```python
def format_docs(docs):
    return "\n\n".join([doc.page_content for doc in docs])

userSendMessage = fileKey.split(".")[0] + " " + userSendMessage
prompt = hub.pull("godk/korean-rag", api_key=langchain_api_key)

rag_chain = (
    {"context": vectorstore.as_retriever() | format_docs, "question": RunnablePassthrough()}
    | prompt
    | self.llm
    | StrOutputParser()
)
return {"generatedText": rag_chain.invoke(userSendMessage)}
```

## 요약
마찬가지로 LLM 체인을 생성하고 여러 문서를 하나의 텍스트로 채워넣는 StuffDocumentsChain을 정의합니다. 전처리 과정으로 줄여진 문서화된 텍스트가 실제 Input에 해당합니다.
<br>StuffDocumentsChain을 통해 문서 내용을 프롬프트에 삽입한 후, LLM을 사용해 요약을 생성하고, 그 결과를 반환합니다.
```python
docs = [Document(page_content=rankedText, metadata={})]
prompt_template = """실제로 프롬프트가 작성되어 있지만 생략하겠습니다.
"""
prompt = PromptTemplate.from_template(prompt_template)
llm_chain = LLMChain(llm=self.llm, prompt=prompt)

stuff_chain = StuffDocumentsChain(llm_chain=llm_chain, document_variable_name="context")
output = stuff_chain.invoke({"input_documents": docs})
return {"generatedText": output["output_text"]}
```


# 8. Result (수행 결과)
### ✅ Frontend / Backend / FastAPI / DLLS 구성에서 모든 동작이 안정적으로 잘 실행되는지 확인
### ✅ FastAPI - DLLS 구성에서 사용자 요청에 따른 LLM 동작이 잘 동작하는지 확인
### ✅ 구성한 사용자 정의형 프로토콜이 잘 동작하는지 확인
### ✅ 시연 결과 모습

![image](https://github.com/user-attachments/assets/09b2e0f6-66a1-4288-a012-81d424b158e9) 
![image](https://github.com/user-attachments/assets/4f6940df-a192-43a9-a4d0-8e425dc25290)
![image](https://github.com/user-attachments/assets/026a0e22-7868-4cf3-9aad-6911ae90a7a6)
![image](https://github.com/user-attachments/assets/acebf5fb-cbfc-4053-96f8-57879e1ee081)
![image](https://github.com/user-attachments/assets/c4017585-5472-48d0-905b-ec3b713c7ce3) 
![image](https://github.com/user-attachments/assets/ffe79024-74c2-42b2-bab7-d759514eb208)  
![image](https://github.com/user-attachments/assets/fdb4576b-e308-4d77-a82b-237857b53184)
![image](https://github.com/user-attachments/assets/e86076e9-ed73-49d9-96f0-4ad491f83783)
![image](https://github.com/user-attachments/assets/cc0f7bb1-fe7f-4457-94ca-1195a3fba255)

<img width="435" alt="image" src="https://github.com/user-attachments/assets/8fda4dc2-8942-45df-9ff8-1f22092e54f6">

<br><br><br>

  
# 9. 한 줄 회고
🤓<b>박주희</b>  
_PYTHON 이라는 언어에 대해 더 깊게 이해할 수 있게 되었고, 그 이해를 바탕으로 DDD 구조의 프로젝트를 진행하여 유지보수가 용이한 코드 작성의 중요성을 체감할 수 있었습니다._

👨‍💻<b>최병준</b>  
_개발에 대해 처음 접해보고 언어와 코드, 형식 등 많은 것을 배우고, 아직 따라하는 수준이지만 내가 해야되는 것을 알 수 있는 유용한 시간이였습니다.

😺<b>조준희</b>  
_PYTHON에 대해 새롭게 접근하는 방법인 DDD를 배울 수 있어서 좋았고, 아직은 따라가기에 급급하지만 노력해야하는 방향성을 알 수 있어서 좋았습니다.

🪐<b>오민수</b>  
_협업을 위한 DDD 구조 설계, 그리고 백로그 작성을 하는 동시에 애자일 방식으로 협업이 진행되면 상당히 효과적이면서도 효율적으로 진행할 수 있다는 것을 배울 수 있었습니다._
